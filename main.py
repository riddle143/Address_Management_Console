# ###@@@$$$ Â© 2023 DAMON M POWELL DBA "VP SOFTWORKS". ALL RIGHTS RESERVED $$$@@@###
# ### Attributions: https://p.yusukekamiyamane.com/ fugue_icons used under
# ###                    Creative Commons Attribution 3.0 License
# ###               PyQt6 used under GPL license
import datetime
import multiprocessing
import os.path
import pickle
import sys
import traceback
import logging
import re
import platform
import pygetwindow as gw
import pandas as pd
from PyQt6.QtGui import QGuiApplication

from functions import sheet_manager as sm
from PyQt6 import QtWidgets, uic, QtGui
from PyQt6.QtCore import QDir, QRunnable, QObject, QThreadPool, QTimer, QDate, pyqtSlot, pyqtSignal, Qt
from PyQt6.QtWidgets import QPushButton, QListWidget, QComboBox, QDialog, QLineEdit, QFileDialog, \
    QDialogButtonBox, QVBoxLayout, QLabel, QMessageBox, QTabWidget, QTableWidget, QTableWidgetItem, QHeaderView, \
    QCheckBox, QDateEdit, QTextBrowser, QCommandLinkButton, QRadioButton, QStyleFactory, QTextEdit

"""log = logging.getLogger()
stdout = colorlog.StreamHandler(stream=sys.stdout)
fmt = colorlog.ColoredFormatter(
    "%(name)s | %(log_color)s%(levelname)s%(reset)s | %(blue)s%(filename)s:%(lineno)s%"
    "(reset)s | %(process)d >>> %(log_color)s%(message)s%(reset)s"
)

stdout.setFormatter(fmt)
log.addHandler(stdout)
log.setLevel(logging.DEBUG)"""

VERSION = "0.0.3"
APPID = f"vpsoftworks.pdm.delmgt.{VERSION}"


app = QtWidgets.QApplication(sys.argv)
basedir = os.path.dirname(__file__)

path = f'{basedir}\\data\\'
if not os.path.exists(path):
    os.mkdir(path)

with open(f'{path}\\log_file.txt', 'w') as f:
    f.write("log_file generated by Address Management Console")
    f.close()

log = logging.getLogger()
log.setLevel(logging.INFO)
file_handler = logging.FileHandler('data/log_file.txt')
fmt = logging.Formatter(
    "%(asctime)s | %(name)s | %(levelname)s | %(filename)s:%(lineno)s | "
    "%(process)d >>> %(message)s"
)
file_handler.setFormatter(fmt)

log.addHandler(file_handler)

try:
    from ctypes import windll  # Only exists on Windows.
    myappid = 'vpsoftworks.pdm.delmgmt.0-0-1'
    windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)
except ImportError:
    log.warning("Windll Import Error, may affect icon")
    pass
app.setWindowIcon(QtGui.QIcon(os.path.join(basedir, 'src/sc.ico')))
if 'Windows' in QStyleFactory.keys():
    app.setStyle('Windows')



loaded_names = list()

class WorkerSignals(QObject):
    """
    Defines the signals available from a running worker thread.

    Supported signals are:

    finished
        No data

    error
        tuple (exctype, value, traceback.format_exc() )

    result
        object data returned from processing, anything

    progress
        int indicating % progress

    """
    started = pyqtSignal()
    progress = pyqtSignal(object)
    finished_report = pyqtSignal(object)
    finished_sheet = pyqtSignal(object)
    finished_update = pyqtSignal()
    error = pyqtSignal(tuple)
    finished = pyqtSignal(bool)


class Worker(QRunnable):
    """
    Worker thread

    Inherits from QRunnable to handler worker thread setup, signals and wrap-up.

    :param callback: The function callback to run on this worker thread. Supplied args and
                     kwargs will be passed through to the runner.
    :type callback: function
    :param args: Arguments to pass to the callback function
    :param kwargs: Keywords to pass to the callback function

    """

    def __init__(self, fn, *args, **kwargs):
        super(Worker, self).__init__()

        # Store constructor arguments (re-used for processing)
        self.fn = fn
        self.args = args
        self.kwargs = kwargs
        self.signals = WorkerSignals()
        # Add the callback to our kwargs
        self.kwargs['progress_callback'] = self.signals.progress

    # noinspection PyUnresolvedReferences
    @pyqtSlot()
    def run(self):
        """Initializes the runner function"""

        # Retrieve args/kwargs here; and fire processing using them
        self.signals.started.emit()
        success = False
        try:
            # exec order a-3, b-3, call fn from within multi-threader
            result = self.fn(*self.args, **self.kwargs)
        except:
            log.exception("Exception in Thread")
            self.signals.progress.emit(99)
            exctype, value = sys.exc_info()[:2]
            self.signals.error.emit((exctype, value, traceback.format_exc()))
        else:
            if type(result) == pd.DataFrame:  # master
                self.signals.finished_sheet.emit(result)
                success = True
            elif type(result) == list:  # report
                if result is not None:
                    self.signals.finished_report.emit(result)
                success = True
            elif type(result) == bool:  # update
                self.signals.finished_update.emit()
                success = True
            else:
                success = False
            self.signals.progress.emit(1)

        finally:
            self.signals.finished.emit(success)  # Done


class expDlg(QDialog):
    # noinspection PyUnresolvedReferences
    def createMasterDialog(self):
        global mainW
        dialog = QFileDialog(self)
        dialog.setFileMode(QFileDialog.FileMode.Directory)
        dialog.setViewMode(QFileDialog.ViewMode.List)
        dialog.setWindowTitle("Choose Folder for Master Update export:")

        if mainW.path is not None:
            sDir = QDir().setPath(mainW.path)
            dialog.setDirectory(sDir)
        else:
            dialog.setDirectory(QDir.homePath())

        if dialog.exec():
            mainW.path = dialog.selectedFiles()[0]
            name = loaded_names[mainW.listWidget.currentRow()]
            savePath = f'{mainW.path}/{name}_Updated.csv'
            self.masterUpdate.to_csv(savePath)
        timer = QTimer
        # noinspection PyTypeChecker
        timer.singleShot(3000, self.close)

    # noinspection PyUnresolvedReferences
    def createReportDialog(self):
        global mainW
        ti = mainW.tabWidget.currentIndex()
        if ti > 0:
            dialog = QFileDialog(self)
            dialog.setFileMode(QFileDialog.FileMode.Directory)
            dialog.setViewMode(QFileDialog.ViewMode.List)
            dialog.setWindowTitle("Choose Folder for Report Export")

            if mainW.path is not None:
                sDir = QDir().setPath(mainW.path)
                dialog.setDirectory(sDir)
            else:
                dialog.setDirectory(QDir.homePath())

            if dialog.exec():
                mainW.path = dialog.selectedFiles()[0]
                if mainW.onDatesFrame is not None:
                    frame: pd.DataFrame = mainW.onDatesFrame
                    name = mainW.sheets[mainW.listWidget.currentRow()].reports[mainW.tabWidget.currentIndex() - 1][0]
                    d = re.sub("/", "-", mainW.filterDate)
                    n = re.sub(" ", "_", name)
                    path = f'{mainW.path}/{n}_{d}.csv'
                    log.info(f'Exported csv as: {path}')
                    frame.to_csv(path, index=False)
                else:
                    mainW.sheets[mainW.listWidget.currentRow()].export_report_csv(ti - 1, mainW.path)
            timer = QTimer()
            # noinspection PyTypeChecker
            timer.singleShot(3000, self.close)
            return True
        elif ti == 0:
            return False

    def radioTog(self):
        if self.mRadBut.isChecked():
            if self.text is not None:
                self.text.setText("")
        elif self.rRadBut.isChecked():
            self.mRadBut.setChecked(False)
            if self.text is not None:
                self.text.setText("")

    def export(self):
        layout = self.verticalLayout

        self.text = QLabel("Complete")
        self.text.setStyleSheet("color: green;")
        self.text.setAlignment(Qt.AlignmentFlag.AlignCenter)
        if self.mRadBut.isChecked():
            self.createMasterDialog()
        elif self.rRadBut.isChecked():
            if not self.createReportDialog():
                self.text.setText("No Report Selected")
                self.text.setStyleSheet("color: red;")
                timer = QTimer
                # noinspection PyTypeChecker
                timer.singleShot(3000, self.close)
        layout.insertWidget(7, self.text)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.text = None
        self.verticalLayout = QVBoxLayout()
        self.commandLinkButton = QCommandLinkButton()
        self.mRadBut = QRadioButton()
        self.rRadBut = QRadioButton()
        uic.loadUi('src/DMexpDiag.ui', self)

        global mainW
        # noinspection PyUnresolvedReferences
        self.masterUpdate = mainW.sheets[mainW.listWidget.currentRow()].updateReport
        tabs: QTabWidget = mainW.tabWidget
        # noinspection PyUnresolvedReferences
        if self.masterUpdate is not None:
            self.mRadBut.setChecked(True)
            if tabs.count() == 1:
                self.rRadBut.setEnabled(False)
            else:
                self.rRadBut.clicked.connect(self.radioTog)
            self.mRadBut.clicked.connect(self.radioTog)


        else:
            self.rRadBut.setChecked(True)
            self.mRadBut.setEnabled(False)

        # noinspection PyUnresolvedReferences
        self.commandLinkButton.clicked.connect(self.export)


class usedMapsDialog(QDialog):

    def update(self) -> None:
        if self.tbHeight != self.textBrowser.height():
            self.tbHeight = self.textBrowser.height()
            self.setup_dialog(self.numbers)
        super().update()

    def __init__(self, number_list, parent=None):
        super().__init__(parent)
        self.textBrowser = QTextBrowser()
        self.copyButton = QPushButton()
        uic.loadUi('src/DMusedMaps.ui', self)
        self.tbHeight = self.textBrowser.height()
        self.setup_dialog(number_list)
        self.numbers = number_list

        def copy():
            output = ""
            for i in number_list:
                output += str(i)
                output += "\n"
            cb = QGuiApplication.clipboard()
            cb.clear(mode=cb.Mode.Clipboard)
            cb.setText(output, mode=cb.Mode.Clipboard)
        # noinspection PyUnresolvedReferences
        self.copyButton.clicked.connect(copy)

    def setup_dialog(self, numbers):

        height = self.tbHeight
        rows = height / 40
        columns = len(numbers) / rows
        # Determine the number of rows and columns
        num_rows = int(round(rows, 0))  # (len(numbers) + 3) // 4
        num_columns = int(round(columns, 0))  # 4

        # Initialize an empty string for the output
        output = ""
        # Iterate over the columns and rows to format the numbers
        for row in range(num_rows):
            for col in range(num_columns):
                # Calculate the index in the original list
                index = row + col * num_rows

                # Check if the index is within the range of the list
                if index < len(numbers):
                    # Append the number to the output with appropriate spacing
                    output += f"{numbers[index]:<8}"

            # Add a line break after each row
            output += "\n"

        self.textBrowser.setText(f"{output}")


class progDlg(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.progLabel = QLabel()
        self.okButton = QPushButton()
        uic.loadUi('src/DMpDiag.ui', self)


# Class for link-processing dialog
class rtReportDialog(QDialog):
    # Custom Dialog

    def __init__(self, parent=None):
        super().__init__(parent)
        # Load the dialog's GUI
        self.lineEdit = QLineEdit()
        self.label = QLabel()
        uic.loadUi("src/DMrptDiag.ui", self)

        self.lineEdit.setPlaceholderText("https://progress.getcircuit.com")


# Class for File errors
# noinspection PyUnresolvedReferences
class ErrorMessageDialog(QDialog):
    def __init__(self, parent=None, style: int = 0, traceback_str=""):
        super().__init__(parent)
        QBtn = QDialogButtonBox.StandardButton.Ok
        self.setFixedSize(280, 140)

        if style == 1:
            self.setWindowTitle("Error")
            message = QLabel("Not a Spreadsheet File")
            message.setAlignment(Qt.AlignmentFlag.AlignCenter)
        elif style == 2:
            self.setWindowTitle("Import Error")
            self.setFixedSize(400, 200)  # Set a fixed size for the dialog
            message = QTextEdit()
            message.setPlainText(traceback_str)  # Set the traceback as plain text
            message.setReadOnly(True)  # Make the text area read-only
        else:
            self.setWindowTitle("Error")
            message = QLabel("No File Selected.")
            message.setAlignment(Qt.AlignmentFlag.AlignCenter)

        self.buttonBox = QDialogButtonBox(QBtn)
        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.setCenterButtons(True)

        self.layout = QVBoxLayout()
        if style == 2:
            info = QLabel("Error Details:")
            self.layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.layout.addWidget(info)
        self.layout.addWidget(message)
        self.layout.addWidget(self.buttonBox)
        self.setLayout(self.layout)


# Class for central GUI
# noinspection PyUnresolvedReferences
class MainWindow(QtWidgets.QMainWindow):
    """Contains Functions vital to the operation of the program,
    handles input, calls commands for sheet operation based on
    event handlers"""

    """ BEGIN MULTITHREADING CODE """
    def timer_update(self):
        if self.count == 1:
            def has_console_window():
                if platform.system() == "Windows":
                    windows = gw.getAllTitles()
                    for window_title in windows:
                        if window_title == "C:\WINDOWS\system32\cmd.exe":
                            return gw.getWindowsWithTitle(window_title)[0]
                else:
                    return None

            console_window = has_console_window()
            if console_window is not None:
                console_window.hide()

        self.count += 1
        self.prDlg.progLabel.setText(f"Importing. Please Wait \n"
                                     f"Elapsed Time: {self.count} seconds")

    def progress_fn(self, mode):
        if mode == 0:
            self.count = 0
            self.prDlg = progDlg(self)
            self.prDlg.progLabel.setText("Importing. Please Wait")
            self.prDlg.okButton.setText("Hide")
            self.prTime = QTimer()
            self.prTime.timeout.connect(self.timer_update)
            self.prTime.start(1000)
            if self.prDlg.exec():
                pass
        elif mode == 1:
            self.prDlg.close()
        elif mode == 99:
            self.prDlg.close()
            log.warning("Did not load Sheet")

    def sheet_complete(self, df):
        loaded_names.append(self.fileName)
        if self.defaultList:
            self.defaultList = False
            self.listWidget.clear()
            self.listWidget.addItem(loaded_names[0])
        else:
            self.listWidget.addItem(loaded_names[-1])

        """if self.listWidget.item(0).text() == "Empty":
            self.listWidget.clear()"""

        self.__update_stats()
        pass

    def report_complete(self, rpt):
        self.__update_tab(rpt[-1])
        self.exportButton.setEnabled(True)

    def update_complete(self):
        self.delete_report()
        self.__update_stats()

    def toggle_ui(self):
        tog = not self.mpRunning
        self.addButton.setEnabled(tog)
        self.delButton.setEnabled(tog)
        self.getButton.setEnabled(tog)
        self.listWidget.setEnabled(tog)
        self.tabWidget.setEnabled(tog)
        self.checkBox.setEnabled(tog)
        self.dateEdit.setEnabled(tog)

    def mp_started(self):
        self.mpRunning = True
        self.toggle_ui()

    def mp_finished(self, success):
        dlg = QMessageBox(self)
        log.info("Multiprocessing Done")
        if success:
            self.prTime.stop()
            self.mpRunning = False
            self.toggle_ui()
            dlg.setWindowTitle("Complete")
            dlg.setText("Import Complete")
            dlg.show()  # note to self, using dlg.exec with QMessageBox causes instability
            timer = QTimer()
            timer.singleShot(2500, dlg.close)

    def mp_failed(self, exc):
        errorDlg = ErrorMessageDialog(self, style=2, traceback_str=str(exc[1]))
        if errorDlg.exec():
            self.toggle_ui()
        pass

    def multi_thread(self, thread_type: int, loc: str = "", ind : int = 0, ind2 : int = 0):
        """
        Multi-state function for creating multiprocessing threads to handle
        resource intensive code that would otherwise freeze the program.

        Thread_type param switches definition of "execute" code to be handed over to
        multiprocessing thread

        Type 0: Execute contains code which calls for an import from the provided path, and
        appends Sheet object to the GUI thread's self.sheets variable, a list of the loaded
        sheets, it then returns the dataframe object to the handle output method of the multi-
        processing thread and the thread executes code to close (self.sheet_finished())

        Type 1:  Execute contains code which takes the index of the currently selected master list
        and attempts to perform a call to Sheet.import_report(), which checks for duplicate sheets
        being added and if none are detected, adds the report to the
        internal list Sheet.reports, and then returns the sheet loaded to the handle output method of
        the multiprocessing thread (self.report_finished())

        :param thread_type: int from 0-1, 0=master, 1=report
        :param loc: can either be local path or link depending on type
        :return: None - completes required actions
        """
        # exec order a-2, b-2 check type of import and pass appropriate fn to multithread result
        if thread_type == 0:  # excel import
            def execute(progress_callback, path):
                log.info("Multiprocess running Master Import")
                progress_callback.emit(0)
                self.sheets.append(sm.Sheet(path))
                return self.sheets[-1].master  # dataframe
            worker = Worker(execute, path=loc)  # Any other args, kwargs are passed to the run function
            worker.signals.finished_sheet.connect(self.sheet_complete)
        elif thread_type == 1:  # website import
            def execute(progress_callback, link, index):
                log.info("Multiprocess running Report Import")
                progress_callback.emit(0)
                # if import is successful, necessary for duplication checking
                self.sheets[index].import_report(link)
                # updates sheet object, the result if true is a new report being appended to sheet.reports
                # consisting of a tuple len(2) with index[0] representing the route name as a string value
                # and index[1] representing the dataframe report
                return self.sheets[index].reports # tuple
            worker = Worker(execute, link=loc, index=ind)
            worker.signals.finished_report.connect(self.report_complete)
        elif thread_type == 2:  # update master
            def execute(progress_callback, index, index2):
                log.info("Multiprocess running Master Update")
                progress_callback.emit(0)
                self.sheets[index].update_master(index2, True)
                return True  # bool
            worker = Worker(execute, index=ind, index2=ind2)
            worker.signals.finished_update.connect(self.update_complete)
            pass
        else:
            worker = None
            raise TypeError("Invalid Parameter Used in multi_thread()", f'{thread_type} is not valid')

        # attach handlers
        if worker is not None:
            worker.signals.progress.connect(self.progress_fn)
            worker.signals.error.connect(self.mp_failed)
            worker.signals.started.connect(self.mp_started)
            worker.signals.finished.connect(self.mp_finished)
            # Execute
            self.threadpool.start(worker)

    """ END MULTITHREAD CODE """

    """Multithread Callers"""

    def __handle_link(self, link, index):
        dom = "https://progress.getcircuit.com"
        if link.startswith(dom) and len(link) > len(dom):
            # exec order (e.o.) b-1 multithread call to __handle_link
            self.multi_thread(1, loc=link, ind=index)
        elif link == "test":  # used for testing
            self.multi_thread(1, loc="src/report.csv", ind=index)

    def __handle_sheet(self, file, filename):
        self.fileName = filename
        self.multi_thread(0, loc=file)

    """ End Callers """

    """GUI METHODS"""

    def __update_stats(self):

        if not self.defaultList:
            maps = str(len(self.sheets[self.listWidget.currentRow()].maps))
            um = str(len(self.sheets[self.listWidget.currentRow()].usedMaps))
            deliv = str(self.sheets[self.listWidget.currentRow()].delivered)
            avg = str(self.sheets[self.listWidget.currentRow()]._7day)
            rem = str(self.sheets[self.listWidget.currentRow()].get_remaining())

            log.info(f'Stats: Maps[{maps}], Used Maps[{um}], Delivered[{deliv}]')

            self.sheetNameL.setText(loaded_names[0])
            self.totMapsL.setText(maps)
            self.totDelL.setText(deliv)
            self.avgL.setText(avg)
            self.totAddrL.setText(str(len(self.sheets[-1].master)))
            self.umL.setText(f'{um}/{maps}')
            self.delByDateL.setText("0")
            self.remDL.setText(rem)
        else:
            self.sheetNameL.setText("")
            self.totMapsL.setText(str(0))
            self.totDelL.setText(str(0))
            self.avgL.setText(str(0))
            self.totAddrL.setText(str(0))
            self.umL.setText(f'0/0')
            self.delByDateL.setText("0")
            self.remDL.setText("0")

    def __update_tab(self, rpt):
        self.__create_table(rpt[1])
        if len(rpt[0]) < 20:
            self.tabWidget.addTab(self.table, rpt[0])
        else:
            self.tabWidget.addTab(self.table, f"{rpt[0][:17]}...")

    def __create_table(self, sheet: pd.DataFrame):

        self.table = QTableWidget(len(sheet), 5)
        self.table.setHorizontalHeaderLabels(["Map", "Address", "Delivered", "Date", "Notes"])
        for i in range(self.table.rowCount()):
            self.table.setItem(i, 0, QTableWidgetItem(str(sheet['MAP'][i])))
            self.table.setItem(i, 1, QTableWidgetItem(sheet['FULL ADDRESS'][i]))
            self.table.setItem(i, 2, QTableWidgetItem(sheet['Visited'][i]))
            self.table.setItem(i, 3, QTableWidgetItem(sheet['Date'][i]))
            self.table.setItem(i, 4, QTableWidgetItem(sheet['Notes'][i]))

        self.table.resizeColumnsToContents()
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.verticalHeader().setSectionResizeMode(QHeaderView.ResizeMode.ResizeToContents)

    def __update_table(self, sheet: pd.DataFrame):
        self.table.setUpdatesEnabled(False)
        self.table.clear()

        self.table.setRowCount(len(sheet))
        self.table.setColumnCount(5)
        self.table.setHorizontalHeaderLabels(["Map", "Address", "Delivered", "Date", "Notes"])
        for i in range(self.table.rowCount()):
            self.table.setItem(i, 0, QTableWidgetItem(str(sheet['MAP'][i])))
            self.table.setItem(i, 1, QTableWidgetItem(sheet['FULL ADDRESS'][i]))
            self.table.setItem(i, 2, QTableWidgetItem(sheet['Visited'][i]))
            self.table.setItem(i, 3, QTableWidgetItem(sheet['Date'][i]))
            self.table.setItem(i, 4, QTableWidgetItem(sheet['Notes'][i]))

        self.table.resizeColumnsToContents()
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.verticalHeader().setSectionResizeMode(QHeaderView.ResizeMode.ResizeToContents)
        self.table.setUpdatesEnabled(True)

    def load_new_reports(self, index):
        for i in self.sheets[index].reports:
            self.__update_tab(i)
            if self.checkBox.isChecked():
                qDate = self.dateEdit.date().getDate()
                dt = datetime.datetime.strptime(f'{qDate[1]}/{qDate[2]}/{qDate[0]}', '%m/%d/%Y')
                date = dt.strftime('%m/%d/%Y')
                self.filterReports(index, date)

    def del_curr_reports(self):
        tabs = self.tabWidget.count()
        for c in range(tabs):
            if tabs > 1:
                self.tabWidget.setCurrentIndex(tabs - 1)
                self.tabWidget.currentWidget().close()
                self.tabWidget.removeTab(tabs - 1)
                tabs -= 1

    def filterReports(self, index, date):
        ti = self.tabWidget.currentIndex()
        dropL = list()
        rdf: pd.DataFrame = self.sheets[index].reports[ti - 1][1]
        log.info(f'Filter date: {date}, Starting Shape: {rdf.shape}')
        for i in rdf.index:
            if rdf['Date'][i] != date:
                dropL.append(i)
        self.onDatesFrame = rdf.drop(index=dropL)
        self.onDatesFrame.reset_index(drop=True, inplace=True)
        log.info(f'Filtered Shape: {self.onDatesFrame.shape}')
        self.__update_table(self.onDatesFrame)

    def export_update_sheet(self, path):
        report: pd.DataFrame = self.sheets[self.listWidget.currentRow()].updateReport
        if report is not None:
            report.to_csv(path)

    def delete_report(self):
        index = self.listWidget.currentRow()
        ind = self.tabWidget.currentIndex() - 1
        self.sheets[index].reports.pop(ind)
        self.tabWidget.currentWidget().close()
        self.tabWidget.removeTab(self.tabWidget.currentIndex())
        if self.tabWidget.count() == 1 and self.defaultList and (self.sheets[index].updateReport is None):
            self.exportButton.setEnabled(False)
    """ END GUI METHODS """

    """ @@@%%% BEGIN EVENT HANDLERS %%%@@@ """

    def get_clicked(self):
        if not self.defaultList:
            index = self.listWidget.currentRow()
            option = self.rptCombo.currentIndex()

            if option == 0:  # import delivery report
                dlg = rtReportDialog(self)
                if dlg.exec():
                    url = "https://progress.getcircuit.com"
                    txt = dlg.lineEdit.text()
                    if txt.startswith(url) and len(txt) > (len(url)+1):
                        self.__handle_link(txt, index)
                    else:
                        message = QMessageBox(self)
                        message.setWindowTitle("Invalid Link")
                        message.setText("Link is not a Circuit url")
                        message.exec()
                        timer = QTimer()
                        timer.singleShot(3000, message.close)
            elif option == 1:  # merge current reports
                if self.tabWidget.count() > 2:
                    self.sheets[index].merge_loaded_reports()
                    self.sel_sheet_change()
                    self.exportButton.setEnabled(True)
                else:
                    dlg = QMessageBox(self)
                    dlg.setWindowTitle("Too Few Reports")
                    dlg.setInformativeText("<center>Must have at least two<br>reports to merge<br></center>")
                    dlg.exec()
                    timer = QTimer()
                    timer.singleShot(3000, dlg.close)

            elif option == 2:  # update master sheet
                if self.tabWidget.currentIndex() != 0:
                    self.multi_thread(2, ind=index, ind2=self.tabWidget.currentIndex()-1)
                elif self.tabWidget.count() > 1 and self.tabWidget.currentIndex() == 0:
                    dlg = QMessageBox(self)
                    dlg.setWindowTitle("Wrong Tab")
                    dlg.layout().setAlignment(Qt.AlignmentFlag.AlignCenter)
                    dlg.setInformativeText("<center>Make sure the correct report is selected, please try "
                                           "again</center>")
                    dlg.exec()
                    timer = QTimer()
                    timer.singleShot(3000, dlg.close)
                else:
                    dlg = QMessageBox(self)
                    dlg.setWindowTitle("No Reports")
                    dlg.layout().setAlignment(Qt.AlignmentFlag.AlignCenter)
                    dlg.setText("No Updates Performed")
                    dlg.exec()
                    timer = QTimer()
                    timer.singleShot(3000, dlg.close)
                pass
            elif option == 3:  # delete current report
                if self.tabWidget.currentIndex() > 0:
                    self.delete_report()
                else:
                    dlg = QMessageBox(self)
                    dlg.setWindowTitle("No Reports")
                    dlg.setText("Nothing to delete...")
                    dlg.exec()
                    timer = QTimer()
                    timer.singleShot(3000, dlg.close)
            elif option == 4:  # delete all reports
                if self.tabWidget.count() > 1:
                    self.sheets[index].reports.clear()
                    self.del_curr_reports()
                    self.exportButton.setEnabled(False)
                else:
                    dlg = QMessageBox(self)
                    dlg.setWindowTitle("No Reports")
                    dlg.setText("Nothing to delete...")
                    dlg.exec()
                    timer = QTimer()
                    timer.singleShot(3000, dlg.close)
            elif option == 5:  # get used maps
                if len(self.sheets) > 0:
                    dialog = usedMapsDialog(self.sheets[index].usedMaps, self)
                    dialog.exec()
                else:
                    dlg = QMessageBox(self)
                    dlg.setWindowTitle("No Masters")
                    dlg.setText("No Master Sheet loaded")

    def add_clicked(self):
        dialog = QFileDialog(self)
        dialog.setFileMode(QFileDialog.FileMode.ExistingFile)
        dialog.setViewMode(QFileDialog.ViewMode.List)
        dialog.setWindowTitle("Select Reporting Sheet for Import")
        dialog.setDirectory(QDir.homePath())
        if dialog.exec():
            file = dialog.selectedFiles()[0]
            if file.endswith('.xlsx'):
                fileName = dialog.selectedFiles()[0].split('/')[-1].removesuffix('.xlsx')
                # exec order (E.O.) A-1 multithread call to __handle_sheet
                self.__handle_sheet(file, fileName)
            else:
                try:
                    msg = ErrorMessageDialog(self, style=1)
                    if msg.exec():
                        pass
                except:
                    log.exception("Error in Spreadsheet Dialog")

    def del_master(self):
        li = self.listWidget.currentRow()
        self.listWidget.takeItem(li)
        self.sheets.pop(li)
        self.del_curr_reports()
        if self.listWidget.count() == 0:
            self.listWidget.addItem("Empty")
            self.defaultList = True
        self.__update_stats()

    def cb_tog(self):
        ti = self.tabWidget.currentIndex()
        ind = self.listWidget.currentRow()
        qDate = self.dateEdit.date().getDate()
        dt = datetime.datetime.strptime(f'{qDate[1]}/{qDate[2]}/{qDate[0]}', '%m/%d/%Y')
        date = dt.strftime('%m/%d/%Y')
        sheet = self.sheets[ind]

        if self.checkBox.isChecked():
            self.filterDate = date
            if ti == 0:
                self.delByDateL.setText(str(sheet.get_del_by_day(date)))
            elif ti > 0:
                self.filterReports(ind, date)
                pass
        else:
            self.fiterDate = None
            if ti > 0:
                self.__update_table(sheet.reports[ti-1][1])
                self.onDatesFrame = None

            self.delByDateL.setText("0")

    def export_clicked(self):
        dlg = expDlg(self)
        dlg.exec()

    def rpt_ind_change(self):
        rptInd = self.rptCombo.currentIndex()
        if rptInd == 0:
            self.getButton.setText("Go...")
        elif rptInd == 1 or rptInd == 2:
            self.getButton.setText("Go")
        elif rptInd == 3 or rptInd == 4:
            self.getButton.setText("Delete")
        else:
            self.getButton.setText("Get")

    def tabChanged(self):
        if self.checkBox.isChecked():
            self.checkBox.setChecked(False)
            self.cb_tog()

    def sel_sheet_change(self):
        if not self.defaultList and len(self.sheets) > 0:
            ind = self.listWidget.currentRow()
            self.__update_stats()
            self.del_curr_reports()
            self.load_new_reports(ind)
            log.info(f'Current Sheet Index: {self.listWidget.currentRow()}')

    def closeEvent(self, event) -> None:
        if len(self.sheets) > 0:
            for sheet in self.sheets:
                sheet.updateReport = None
                if len(sheet.reports) > 0:
                    try:
                        file_list = os.listdir('tmp')
                        for file_name in file_list:
                            file_path = os.path.join('tmp', file_name)
                            os.remove(file_path)
                    except FileNotFoundError:
                        pass
                    except PermissionError:
                        pass
            save_object((self.sheets, loaded_names))
        else:
            try:
                os.remove('data/state.pck')
            except FileNotFoundError:
                log.exception(f" Save File not found.")
            except PermissionError:
                log.exception(f"Permission denied: unable to delete save file'.")
        super(MainWindow, self).closeEvent(event)

    """END EVENT HANDLERS"""

    """INIT"""

    def __init__(self, *args, **kwargs):
        super(MainWindow, self).__init__(*args, **kwargs)
        # def loadUI():
        self.path = None
        self.onDatesFrame = None
        self.prTime = None
        self.prDlg = None
        self.count = 0
        self.mpRunning = False
        self.addButton = QPushButton()
        self.delButton = QPushButton()
        self.getButton = QPushButton()
        self.exportButton = QPushButton()
        self.listWidget = QListWidget()
        self.rptCombo = QComboBox()
        self.tabWidget = QTabWidget()
        self.checkBox = QCheckBox()
        self.dateEdit = QDateEdit()

        self.sheetNameL = QLabel()
        self.totMapsL = QLabel()
        self.totDelL = QLabel()
        self.avgL = QLabel()
        self.totAddrL = QLabel()
        self.umL = QLabel()
        self.delByDateL = QLabel()
        self.remDL = QLabel()

        uic.loadUi('src/DM.ui', self)
        self.tabWidget.removeTab(1)
        self.listWidget.addItem("Empty")
        self.listWidget.setCurrentRow(0)
        self.rptCombo.addItems(['Download Delivery Report', 'Merge Current Reports', 'Update Master List', 'Delete Current Report',
                                'Delete All Reports', 'Get Used Maps List'])
        self.rptCombo.setCurrentIndex(0)
        self.rptCombo.currentIndexChanged.connect(self.rpt_ind_change)
        self.getButton.clicked.connect(self.get_clicked)
        self.addButton.clicked.connect(self.add_clicked)
        self.delButton.clicked.connect(self.del_master)
        self.exportButton.clicked.connect(self.export_clicked)
        self.checkBox.toggled.connect(self.cb_tog)
        self.tabWidget.currentChanged.connect(self.tabChanged)
        self.exportButton.setEnabled(False)
        self.listWidget.itemSelectionChanged.connect(self.sel_sheet_change)

        # icon = self.style().standardIcon(QStyle.StandardPixmap.SP_DialogHelpButton)
        # loadUI()
        # self.setWindowIcon(icon)

        def declareVars():
            self.defaultList = True
            self.worker = WorkerSignals()
            self.threadpool = QThreadPool()
            # log.info("Multithreading with maximum %d threads" % self.threadpool.maxThreadCount())
            self.sheets = list()
            self.dateEdit.setDate(QDate.currentDate())

        declareVars()

        # if there's a save file, load from it.
        if os.path.exists('data/state.pck'):
            global loaded_names
            load: tuple = load_info()
            loaded_names = load[1]
            self.listWidget.clear()
            self.listWidget.addItems(loaded_names)
            self.sheets: list[sm.Sheet] = load[0]
            testSheet = self.sheets[0]
            if len(testSheet.reports) != 0:
                log.info(f"Total Reports Loaded: {len(testSheet.reports)}")
                self.exportButton.setEnabled(True)
            for i in self.sheets:
                if len(i.reports) != 0:
                    for s in i.reports:
                        self.__update_tab(s)
                else:
                    log.warning("No Reports Loaded")

            log.info("Loaded Info from Pickle")
            self.defaultList = False

        self.__update_stats()

    """END MAIN WINDOW"""


"""BEGIN PACKAGE FUNCTIONS"""


def save_object(obj):
    try:
        if os.path.exists('data'):
            try:
                with open('data/state.pck', 'wb') as file:
                    pickle.dump(obj, file, pickle.HIGHEST_PROTOCOL)
            except:
                log.exception("Error Unpickling")
    except FileNotFoundError:
        log.exception("No Pickle File Found:")


def load_info():
    try:
        with open(f'data/state.pck', 'rb') as f:
            data: tuple = pickle.load(f)
    except:
        log.exception("Error Unpickling")
        return False
    else:
        return data


"""END PACKAGE FUNCTIONS"""

mainW = None
def main():
    # Use a breakpoint in the code line below to debug your script.
    global mainW
    mainW = MainWindow()
    mainW.show()
    app.exec()


# Press the green button in the gutter to run the script.
if __name__ == '__main__':
    multiprocessing.freeze_support()
    main()
    pass
